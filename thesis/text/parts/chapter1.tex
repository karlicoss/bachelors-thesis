\chapter{Обзор предметной области}
\label{chapter1}

\section{Аксиоматизация квантовой механики}

% http://thisquantumworld.com/wp/a-critique-of-quantum-mechanics/the-standard-axioms/

Существуют несколько математических формализаций аппарата квантовой механики, TODO

\begin{enumerate}
\item С каждой физической системой ассоциировано гильбертово пространство $\hilb{}$ над полем комплексных чисел $\mathbb{C}$ со скалярным произведением $\ip{\cdot}{\cdot}$. Состояния квантовой системы — вектора единичной длины в $\hilb{}$.
\item Каждая \textit{наблюдаемая} физическая величина (координата, импульс, спин, энергия, и т.д.) ассоциирована с самосопряженным оператором, действующим в пространстве $\hilb{}$. Заметим, что многим наблюдаемым соответствуют неограниченные операторы (например, координате соответствует оператор $(\hat{x} \psi)(x) = x \psi(x)$), что означает, что такие наблюдаемые не могут быть определены на всем пространтве $\hilb{}$, и требуется помимо формального выражения для оператора задавать его домен.
\item Самосопряженный оператор, плотно опеределенный на гильбертовом пространстве, имеет полную систему собственных векторов. TODO
\item Математическое ожидание наблюдаемой в состоянии $\psi$, равно 
\item При совершении измерения системы в квантовом состоянии $\psi$, вероятность обнаружить ее в квантовом состоянии $\varphi$, равна $|\ip{\psi}{\varphi}|^2$.
\item Если $\hilb{1}$ — гильбертово пространство, ассоциированное с физической системой $S_1$, а $\hilb{2}$ — гильбертово пространство
\item Унитарная эволюция: TODO
\end{enumerate}

TODO чистые состояния и смешанные

\section{Уравнение Шредингера}
Уравнение Шредингера описывает временную эволюцию чистых состояний нерелятивистсих квантовых систем во времени. Оно записывается как:
\[
i \hbar \pdv{t} \Psi(t) = \hat{H} \Psi(t)
\]
, где $i$ — мнимая единица, $\hbar$ — приведенная постоянная Планка, $\hat{H}$ — гамильтониан, оператор энергии системы. Cпектр гамильтониана в общем случае состоит из дискретной и непрерывной частей, и представляет собой множество возможных значений энергии системы, которые можно получить при ее измерении.

Зная $\Psi(0)$, состояние системы в начальный момент времени, можно получить формальное решение уравнения (1 TODO), как:
\[
\Psi(t) = e^{-i H t / \hbar} \Psi(0)
\]
, где экспоненциирование оператора следует интерпретировать как возведение в степень в базисе из собственных функций оператора TODO мутно, и что делать с непрерывным спектром?

\subsection{Гамильтониан}
TODO написать про гамильтониан для обычной частицы и в магнитном поле

\section{Ток вероятности}
Ток вероятности (англ. probability current) — величина, описывающая ``течение'' вероятности через единицу поверхности за единицу времени. TODO 

% TODO https://en.wikipedia.org/wiki/Probability_current#Spin-0_particle_in_an_electromagnetic_field

Для нерелятивистской квантовой системы без спина, то есть, соответствующей гамильтониану $\hat{H} = - \frac{\hbar^2}{2m} \laplacian + V(\vb{r}, t)$, поток вероятности рассчитывается как:

\[
\vb{j}(\vb{r}, t) = \frac{\hbar}{2 m i} (\psi(\vb{r}, t)^* \grad_r{\psi(\vb{r}, t)} - \psi(\vb{r}, t) \grad_r{\psi^*(\vb{r}, t))}
\]

Для магнитного поля: TODO

\section{Коэффициент прохождения}
Интуитивно, коэффициент прохождения — отношение ``количества'' волны, прошедшей через барьер к ``количеству'' волны, на этот барьер падающий. Формально, коэффициент прохождения определяется как
\[
T = \frac{|j_{trans}|}{j_{inc}}
\]
, где $j_{trans}$ — ток вероятности волны, прошедшей через барьер, а $j_{inc}$ — ток вероятности волны, падающей на барьер.

TODO определять через ток вероятности не круто. Написать что не зависит от времени в ``состояниях рассеивания'', что интегрируем по сечению и считаем в бесконечно далекой точке, что по некоторым координатам занулится.

\section{Фиксирование нотации}
\subsection{Функция Грина}
Термин ``функция Грина'' используется как минимум в двух значениях:

\begin{itemize}
\item как интегральное ядро резольвентного оператора: $G(x, s; \lambda)$ — ядро оператора $R(\lambda) = \frac{1}{\lambda I - L}$
\item как решение дифференциального уравнения $L_x G(x, s) = -\delta(x - s)$
\end{itemize}

Заметим, что в физике и математике сложилась неоднозначность в определении функции Грина:


\begin{itemize}
\item Physics notation: $$L_x G(x, s) = -\delta(x - s)$$
\item Mathematics notation: $$L_x G(x, s) = \delta(x - s)$$
\end{itemize} 

That is, they differ up to sign. In particular, from the notation follows that eigenfunction expansion is defined as: 

\begin{itemize}
\item Physics notation: $$G(x, s) = -\sum\limits_n \frac{\psi_n(x) \psi_n^*(s)}{\lambda_n}$$
\item Mathematics notation: $$G(x, s) = \sum\limits_n \frac{\psi_n(x) \psi_n^*(s)}{\lambda_n}$$
\end{itemize} 

We use PHYSICS notation.

\subsection{Скалярное произведение}
There is some ambiguity in defining antilinearity property of the inner product in vector space $V$ over the field $\mathbb{C}$ of complex numbers:

\begin{itemize}
\item Physics: \textbf{anti}linear in the \textit{first} argument, linear in the \textit{second} argument:
\[
\forall x, y, z \in V: \forall a, b \in \mathbb{C}: \ip{ax + by}{z} = \cconj{a} \ip{x}{z} + \cconj{b} \ip{y}{z}
\]
\[
\forall x, y, z \in V: \forall a, b \in \mathbb{C}: \ip{x}{ay + bz} = a \ip{x}{y} + b \ip{x}{y}
\]
\item Mathematics: linear in the \textit{first} argument, \textbf{anti}linear in the \textit{second} argument:
\[
\forall x, y, z \in V: \forall a, b \in \mathbb{C}: \ip{ax + by}{z} = a \ip{x}{z} + b \ip{y}{z}
\]
\[
\forall x, y, z \in V: \forall a, b \in \mathbb{C}: \ip{x}{ay + bz} = \cconj{a} \ip{x}{y} + \cconj{b} \ip{x}{y}
\]
\end{itemize}

We stick to the PHYSICS definition. For instance, that means that inner product in $L^2(a, b)$ is defined as $\ip{f}{g} = \int\limits_a^b \cconj{f(x)} g(x) dx$.

\section{Различные граничные условия для уравнения Шредингера}

\section{Обобщенные точечные взаимодействия}
TODO
\subsection{Шкалы гильбертовых пространств}
TODO
\subsection{Пространство Понтрягина}
TODO


Эволюционный алгоритм~\cite{general_EA}~--- это метод решения задач оптимизации. Данный подход основан на идеях, заимствованных из биологической эволюции: 
естественный отбор, мутация, скрещивания и наследование признаков. Каждая итерация алгоритма характеризуется набором особей, называемым поколением. На множестве 
особей вводят функции приспособленности, чтобы количественно оценивать, насколько заданная особь близка к верному решению. При помощи оператора скрещивания 
(кроссовера) по двум особям генерируется особь для следующего поколения. Оператор мутации вносит малые случайные изменения особи. Начальное поколение обычно 
формируется случайным образом. При выборе особей для создания нового поколения наиболее приспособленные имеют больше шансов. Общая схема эволюционного 
алгоритма представлена на листинге~\ref{lst:ea}.

\begin{algorithm}[h!]
\caption{Общая схема эволюционного алгоритма}
\label{lst:ea}
\begin{algorithmic}[1]
  \STATE {Создать начальное поколение}
  \STATE {Вычислить значение функции приспособленности для каждой особи}
  \WHILE {(условие останова эволюционного алгоритма не выполнено)}
    \STATE {Выбирается подмножество особей текущего поколения}
    \STATE {Применяя операторы мутации и кроссовера к выбранным особям, генерируются новые}
    \STATE {Вычисляется значение функции приспособленности для сгенерированных особей}    
    \STATE {Формируется новое поколение, заменяя новыми особями наименее приспособленных}
  \ENDWHILE  
\end{algorithmic}
\end{algorithm}

В качестве критерия останова часто используют следующие условия:
\begin{itemize}
 \item найдено верное решение;
 \item достигнуто заданное количество поколений;
 \item превышено заданное время работы;
 \item превышено заданное число вызовов функции приспособленности;
 \item за заданное число поколений не произошло улучшение.
\end{itemize}

Эволюционные алгоритмы применяются для решения задач, к которым не применимы традиционные методы оптимизации. Одной из областей применения эволюционных 
алгоритмов является автоматическая генерация тестов для программного обеспечения.

\section{Существующие подходы}
Рассмотрим некоторые методы, применяемые для автоматической генерации покрывающего набора тестов.

\subsection{Применение алгоритмов оптимизации}
Покрытие фрагмента кода тестом можно рассматривать как задачу оптимизации. В качестве оптимизируемой функции используется количественная оценка того, насколько 
сгенерированный тест покрывает заданный фрагмент кода.

Рассмотрим некоторые алгоритмы, применяемые для решения данной задачи \cite{review_harman,sbst}.
\begin{itemize}
 \item Алгоритм восхождения на вершину (\textit{Hill climbing}) \cite{hill_climbing_harman}. На каждой итерации алгоритма генерируется 
набор ``ближайших соседей'', полученный при помощи небольших изменений текущего кандидата. Существует два способа выбора кандидата для следующей итерации. Можно 
перебирать соседей, пока не найдется лучший кандидат, либо выбрать лучшего из всех соседей. Алгоритм завершает работу, если невозможно улучшить текущее 
решение. 
 \item Метод отжига \cite{SA}. В отличие от предыдущего алгоритма может выбрать худшее решение с некоторой вероятностью. Эта вероятность уменьшается с номером 
итерации алгоритма. Вследствие этого данный подход менее подвержен схождению в локальному оптимуму вместо глобального.

 \item Применение эволюционных алгоритмов для построения набора тестов получило широкое распространение 
\cite{evolutionary_tonella,whole_test_suite_generation,structural_test_data_generation}. Используются различные эволюционные операторы, функции 
приспособленности, а также по-разному кодируются особи. Однако не существует оптимального подхода.
\end{itemize}

\subsection{Символьное выполнение}
При символьном выполнении~\cite{symbolic_sbst} моделируется выполнение программы, при котором часть входных переменных представляется в символьном виде. Можно 
выделить два основных подхода~\cite{symbolic_execution}: на основе статического или динамического анализа программы.

При статическом подходе для каждой возможной траектории выполнения с помощью символьного выполнения задаются ограничения на параметры тестируемой программы. 
Если для некоторой траектории возможно удовлетворить все ограничения, то вдоль нее будет сгенерирован тест.

Однако статический подход неприменим, если тестируемая программа содержит ограничения вне области видимости статического анализатора. Рассмотрим программу, 
приведенную на листинге~\ref{lst:bad_static}.

\begin{snippet}[caption={Пример, на котором не применим статический подход}, label={lst:bad_static}]
  def testMethod(x, y) {
      if (x == hash(y)) {
          return 0	// %*целевое ветвление*)
      }
      return 1
  }
\end{snippet}

Допустим, что в целях безопасности, анализатор кода не имеет доступ к функции \texttt{hash}. Значит, без запуска программы невозможно подобрать \texttt{x} так, 
чтобы он был равен \texttt{hash(y)}.

Для обхода таких ситуаций используется динамический подход. При этом генерация теста происходит следующим образом:
\begin{enumerate}
 \item Тестируемая программа выполняется на случайных входных данных.
 \item Динамический анализатор записывает ограничения на входные параметры тестируемой программы вдоль траектории выполнения.
 \item Удовлетворив ограничениям, подбирается такой тест, чтобы следующий запуск прошел по другой траектории.
\end{enumerate}

Таким образом, при запуске программы~\ref{lst:bad_static} на случайных значениях, будет посчитано \texttt{hash(y)}. Взяв посчитанное значение \texttt{hash(y)} 
вместо \texttt{x}, можно удовлетворить ограничениям.

При использовании данного подхода возникают проблемы с масштабированием \cite{symbolic_limitations}. При тестировании более сложных программ возрастает как 
длина траекторий выполнения, так и число символьных переменных. При увеличении количества ограничений, накладываемых на параметры тестируемой программы, 
существенно увеличивается время, затрачиваемое на их удовлетворение.

\section{Java Virtual Machine}

В данной работе рассматривается покрытие тестами программ, работающих на \textit{Java Virtual Machine (JVM)}. \textit{JVM}~\cite{jvm_spec} 
--- основа \textit{Java} платформы, отвечающая за аппаратную и операционную независимость программ. \textit{JVM} имеет определенный набор инструкций и 
управляет памятью во время выполнения программы. \textit{JVM} работает с файлами определенного бинарного формата, называемыми \textit{class}-файлами, в которых 
содержатся последовательность инструкций, таблица символов и другая вспомогательная информация.

\subsection{Типы данных}
Типы данных \textit{JVM} делятся на примитивные и ссылочные. Для каждой инструкции определен тип аргументов, к которым она применяется. Например, инструкции 
\texttt{iadd}, \texttt{ladd}, \texttt{fadd} и \texttt{dadd} складывают два численных значения и возвращают результат, но каждая из этих инструкций 
предназначена для определенного типа данных: \texttt{int}, \texttt{long}, \texttt{float} и \texttt{double} соответственно.

Примитивные типы данных делятся на численные, логический (\texttt{boolean}) тип и тип адреса возврата (\texttt{returnAddress}). В свою очередь, числовые типы 
данных делятся на:
\begin{itemize}
 \item целочисленные
 \begin{itemize}
  \item \texttt{byte}, от $-127$ до $128$
  \item \texttt{short}, от $-2^{15}$ до $2^{15} - 1$
  \item \texttt{int}, от $-2^{31}$ до $2^{31} - 1$
  \item \texttt{long}, от $-2^{63}$ до $2^{63} - 1$
  \item \texttt{char}, символ Unicode, 2 байта
 \end{itemize}
 \item числа с плавающей точкой, соответствующие стандарту IEEE 754
 \begin{itemize}
  \item \texttt{float}, 32-битное вещественное число одинарной точности
  \item \texttt{double}, 64-битное вещественное число двойной точности
 \end{itemize}
\end{itemize}

Значениями, имеющими тип адреса возврата, являются указатели на инструкции \textit{JVM}. В отличие от данных численных типов, значения типа адреса возврата не 
могут быть изменены в процессе работы программы.

Несмотря на то, что \textit{JVM} декларирует тип \texttt{boolean}, для него предоставляется лишь ограниченная поддержка. \textit{JVM} не имеет инструкций, 
специально предназначенных для значений типа \texttt{boolean}. Для работы со значениями типа \texttt{boolean} используются инструкции, предназначенные для 
работы со значениями типа \texttt{int}, причем \texttt{true} соответствует единица, а \texttt{false}~--- ноль.

Cсылочные типы данных делятся на классы, массивы и интерфейсы. Данными, имеющими такие типы, соответственно являются динамически создаваемые экземпляры 
классов, массивов, а также экземпляры классов и массивы, которые реализуют заданный интерфейс.

В процессе выполнения программы \textit{JVM} некоторые типы данных хранятся одинаково, причем размер выделяемой памяти зависит от категории типа. Способ 
хранения типы данных зависит от соответствующего ему типа данных времени выполнения. Соответствие фактических типов данных и типов времени выполнения, а также 
категории указаны в таблице~\ref{tab:type_compatibility}.

\begin{table}[ht]
\caption{Таблица соответствий типов данных \textit{JVM}}
\label{tab:type_compatibility}
\begin{tabular}{|c|c|c|}
\hline
Фактический тип & Тип времени выполнения & Категория \\
\hline
\texttt{boolean} & \texttt{int} & 1 \\
\hline
\texttt{byte} & \texttt{int} & 1 \\
\hline
\texttt{char} & \texttt{int} & 1 \\
\hline
\texttt{short} & \texttt{int} & 1 \\
\hline
\texttt{int} & \texttt{int} & 1 \\
\hline
\texttt{float} & \texttt{float} & 1 \\
\hline
\texttt{reference} & \texttt{reference} & 1 \\
\hline
\texttt{returnAddress} & \texttt{returnAddress} & 1 \\ 
\hline
\texttt{long} & \texttt{long} & 2 \\
\hline
\texttt{double} & \texttt{double} & 2 \\
\hline
\end{tabular}
\end{table}

\subsection{Среда выполнения}
\label{jvm_env}
Во время работы \textit{JVM} использует память двух видов: куча и стек.

Куча предназначена для хранения экземпляров классов и массивов. Очистка кучи происходит автоматически с помощью сборщика мусора. Куча общая для всех потоков 
\textit{JVM} и инициализируется при старте \textit{JVM}.

В отличие от  кучи, стек для каждого потока свой. Его инициализация происходит в момент создания потока.

При выполнении программы на каждый вызов метода создается фрейм~--- данные, необходимые для выполнения метода~--- который кладется на стек. После завершения 
выполнения метода фрейм удаляется со стека, вне зависимости от того, было ли брошено необработанное исключение или нет.

Фрейм, соответствующий методу, выполняемому в данный момент, называется активным. После завершения текущего метода, активным становится предыдущий фрейм. 
Каждый фрейм выделяется локально для каждого потока, поэтому остальные потоки не могут на него ссылаться.

Каждый фрейм содержит:
\begin{itemize}
 \item набор локальных переменных;
 \item стек операндов;
 \item ссылку на набор констант текущего метода.
\end{itemize}

Локальные переменные пронумерованы, начиная с нуля, и обращение к ним происходит по соответствующему номеру. \textit{JVM} использует локальные переменные для 
передачи параметров при вызове метода, причем нулевым параметром является ссылка на объект, чей метод был вызван. Для хранения значений типа, относящегося 
первой категории, используется одна локальная переменная, а для значений типа, относящегося ко второй категории, используются две последовательные локальные 
переменные.

Максимальный размер стека операндов определяется на этапе компиляции. При выполнении инструкции аргументы забираются со стека операндов и результат выполнения 
кладется на стек. Кроме того, стек операндов используется для передачи аргументов вызываемым методам. При вызове метода аргументы забираются со стека операндов 
текущего фрейма, создается новый фрейм и аргументы сохраняются в локальных переменных созданного фрейма. Результат кладется на стек операндов того фрейма, из 
которого был вызван метод. После этого созданный фрейм удаляется. Значения типов данных, относящихся первой категории, занимают одну ячейку стека операндов, в 
то время как значения типов, относящихся второй категории~--- две.

Каждый класс и интерфейс имеет набор констант. В нем содержатся как численные константы, известные на момент компиляции, так и ссылки на методы и поля, 
значения которых вычисляются во время выполнения.

\subsection{Набор инструкций}
Перечислим инструкции \textit{JVM}, которые затронуты в данной работе. 
% Подробное описание инструкций приведено в приложении [ссылка].

\subsubsection{Инструкции сохранения и загрузки}
Инструкции загрузки и сохранения предназначены для передачи значений между стеком операндов и локальными переменными:

\begin{itemize}
 \item Загрузка значений из локальной переменной на стек операндов: \texttt{iload}, \texttt{fload}, \texttt{dload}, \texttt{lload}, \texttt{aload};
 \item Сохранение значений со стека операндов в локальные переменные: \texttt{istore}, \texttt{fstore}, \texttt{dstore}, \texttt{lstore}, \texttt{astore};
 \item Загрузка констант на стек операндов: \texttt{bipush}, \texttt{sipush}, \texttt{ldc}, \texttt{aconst\_null}, \texttt{iconst}, \texttt{fconst}, 
\texttt{lconst}, \texttt{dconst}.
\end{itemize}

\subsubsection{Инструкции ветвления}
\begin{itemize}
 \item Сравнение двух операндов типа \texttt{int}: \texttt{if\_icmpeq}~($=$), \texttt{if\_icmpne}~($\neq$), \texttt{if\_icmplt}~($<$), 
\texttt{if\_icmpge}~($\ge$), \texttt{if\_icmpgt}~($>$), \texttt{if\_icmple}~($\le$);
 \item Сравнение операнда типа \texttt{int} c нулем: \texttt{ifeq}, \texttt{ifne}, \texttt{iflt}, \texttt{ifge}, \texttt{ifgt}, \texttt{ifle};
 \item Сравнение ссылочных типов: \texttt{if\_acmpeq}, \texttt{if\_acmpne}, \texttt{ifnonnull}, \texttt{ifnull};
 \item Сравнения: \texttt{dcmpg}, \texttt{dcmpl}, \texttt{fcmpg}, \texttt{fcmpl}, \texttt{lcmp}.
\end{itemize}

\section{Scala}
\textit{Scala}~\cite{scala_lang}~--- статически типизированный язык программирования, сочетающий в себе возможности объектно-ориентированного и функционального 
программирования. Система типов \textit{Scala} специально спроектирована для удобства создания компонентного программного обеспечения. При этом \textit{Scala} 
полностью совместима с \textit{Java}.

В отличие от \textit{Java}, в \textit{Scala} имеется поддержка типажей (\texttt{trait}), которые подобны интерфейсам, но могут содержать реализацию методов. 
Как и в случае с интерфейсами, возможно множественное наследование от типажей. При определении типажа можно указывать дополнительные типажи, необходимые 
создания его экземпляра. Это можно использовать для конфигурации эволюционного алгоритма (ЭА). 

Рассмотрим пример, приведенный на листинге~\ref{lst:scala_config}. При создании экземпляра ЭА (\textit{EvolutionaryAlgorithm}) необходимо указать оператор 
мутации (\textit{Mutation}).Таким образом, можно использовать один и тот же ЭА, но с различными операторами мутации. В приведенном примере определено 
два типажа мутации целого числа: \textit{IncrementMutation} и \textit{SquareMutation}. Экземпляры ЭА~--- \textit{incEA} и \textit{squareEA}~--- различаются
используемыми операторами мутации.

\begin{snippet}[caption=Пример конфигурации эволюционного алгоритма, label={lst:scala_config}]
trait Mutation[G] {  
  def mutate(g : G) : G
}

trait EvolutionaryAlgorithm[G] {
  needs : Mutation[G] =>  // %*определение необходимого типажа*)
  ...
}

trait IncrementMutation extends Mutation[Int] {
  def mutate(g : Int) = g + 1
}

traint SquareMutation extends Mutation[Int] {
  def mutate(g : Int) = g * g
}

val incEA = new EvolutionaryAlgorithm[Int] with IncrementMutation

val squareEA = new EvolutionaryAlgorithm[Int] with SquareMutation
\end{snippet}

\section{Выводы по главе \ref{chapter1}}
Рассмотрены некоторые существующие подходы к автоматизированному покрытию кода тестами. Описаны различные структурные метрики покрытия кода. Кратко описана 
спецификация \textit{JVM}. Кратко описаны особенности языка программирования \textit{Scala}.





