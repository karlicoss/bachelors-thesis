# This file was *autogenerated* from the file racec.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_2p0 = RealNumber('2.0'); _sage_const_0p0 = RealNumber('0.0'); _sage_const_100 = Integer(100); _sage_const_5p0 = RealNumber('5.0'); _sage_const_1p0 = RealNumber('1.0'); _sage_const_0 = Integer(0); _sage_const_10p0 = RealNumber('10.0'); _sage_const_0p232 = RealNumber('0.232')
import scipy.special

jn_zeros = lambda x, y: scipy.special.jn_zeros(int(x), int(y))
# jn = lambda x, y: scipy.special.jn(int(x), float(y))
def jn(x, y):
	# print(y)
	return scipy.special.jn(int(x), float(y))


class CylinderDeltaScattering:
	# energy: wave full energy
	# R : wire radius
	# m : magnetic quantum number
	# aa : delta well "strength"
	def __init__(self, energy, R, m, aa, maxn = _sage_const_100 ):
		self.energy = energy
		self.R = R
		self.m = m
		self.zeros = jn_zeros(self.m, maxn)
		self.aa = aa

	def get_theta_function(self):
		def fun(theta):
			return CC(exp(I * self.m * theta) / (_sage_const_2  * pi))
		return fun

	# n >= 1
	def get_phi_energy(self, n):
		return (self.zeros[n - _sage_const_1 ] / self.R)**_sage_const_2 
	# n >= 1
	def get_phi_function(self, n):
		def fun(r):
			# print("point")
			return CC(sqrt(_sage_const_2p0 ) / (self.R * jn(abs(self.m) + _sage_const_1 , self.zeros[n - _sage_const_1 ])) * jn(self.m, self.zeros[n - _sage_const_1 ] * r / self.R))
		return fun

	# scattering from the left, incident amplitude is 1.0
	def get_varphi_function(self, n):
		# en = self.energy - self.get_phi_energy(n)
		# assert(en > 0)
		# def fun(z):
		# 	return CC(exp(I * sqrt(en) * z))
		# return fun
		en = self.energy - self.get_phi_energy(n)
		k = sqrt(abs(en))
		if en > _sage_const_0 :			
			RR = -(self.aa / (self.aa + _sage_const_2  * I * k)) # reflection amplitude
			TT = _sage_const_1  - self.aa / (self.aa + _sage_const_2  * I * k)# transmisstion amplitude
			def fun(z):
				# print("point2")
				if z < _sage_const_0 :
					return CC(exp(I * k * z) + RR * exp(-I * k * z))
				else:
					return CC(TT * exp(I * k * z))
			return fun
		else:
			def fun(z):
				# print("point2")
				if z < _sage_const_0 :
					return exp(k * z)
				else:
					return exp(-k * z)
			return fun
			# raise ValueError("energy should be greater than zero")

def alala():
	energy = _sage_const_0p232 
	m = _sage_const_0 
	n = _sage_const_1 
	R = _sage_const_5p0 
	d = _sage_const_10p0 
	aa = _sage_const_1p0 

	cs = CylinderDeltaScattering(energy, R, m, aa)
	print(cs.get_phi_energy(n))
	theta = cs.get_theta_function()
	phi = cs.get_phi_function(n)
	varphi = cs.get_varphi_function(n)
	wf = lambda z, r: phi(r) * varphi(z)
	rwf = lambda z, r: wf(z, r).real()
	iwf = lambda z, r: wf(z, r).imag()
	pf = lambda z, r: wf(z, r).norm()
	# wf = lambda t, r, z: theta(t) * phi(r) * varphi(z)
	# rwf = lambda t, r, z: wf(t, r, z).real()
	# pf = lambda t, r, z: wf(t, r, z).norm()
	# t, r, z = var('r t z')
	# T = Cylindrical('height', ['radius', 'azimuth'])

	p = density_plot(pf, (-d, d), (_sage_const_0p0 , R), cmap = 'jet', axes_labels = ['d', 'r'], aspect_ratio = _sage_const_1 , plot_points = _sage_const_100 )
	p.save("plot.png")
	p.show()

	# f(t, r)
	# def to_cartesian(f):
		# def fun(x, y):
			# return f(atan2(y, x), sqrt(x^2 + y^2))
		# return fun

	# f = to_cartesian(lambda t, r: rwf(t, r, 0.0))

	# T.transform(radius = r, azimuth = t, height = z)
	# print(rwf(0.0, 0.0, 0.0))
	# plot3d(lambda t, r: pf(t, r, 0.0), (-pi, pi), (0.01, R)).show()
	# plot(varphi, 0.0, 1.0).show()
	# print(pf(0.0, 0.0))
	# print(pf(0.0, d))
	# plot3d(rwf, (0.0, R), (0.0, d), axes_labels = ['r', 'z']).show(viewer = 'jmol')

alala()

# sphere().show()

input()
